---
type : "post"
date: 2025-01-19
title: "slf4j 구현체를 만들며 배우는 로깅"
slug: "/custom-logging-for-learn-slf4j"
tags: ['slf4j', '로깅']
---

부끄러운 말이지만 slf4j lombok 애노테이션을 습관처럼 쓰면서도 구체적인 내용에 대해 별로 고민해본적이 없다. 이번에 서비스 모니터랑과 알람을 고민하면서 로깅 라이브러리들을 살펴보는 와중에 slf4j가 단순 인터페이스라는 것을 알았다. 자주 사용하는 logback은 slf4j를 구현한 구현체였던 것이다. '아 그럼 나도 학습할 겸 slf4j를 구현한 구현체를 만들어 볼 수 있겠구나'라는 생각이 들었다. 특히 logback에서 spring profile에 따라 분리하거나, 로그를 JSON 포맷으로 만드는 설정이 xml 형태인 것이 마음에 들지 않았다. 그래서 커스텀한 로깅 클래스를 만들며 공부해보기로 했다.


## SLF4J의 등장 배경과 의미

초기 자바 개발에서 로깅은 단순히 `System.out.println()`을 사용하는 것이 전부였다. 프로그램의 규모가 커지고 운영 환경이 다양해지면서 로깅에 대한 더 많은 요구사항이 생겼다. [^1]

2002년 JDK 1.4에서 `java.util.logging(JUL)`이 공식 로깅 API로 등장했지만, 이미 시장에서는 1999년에 나온 Log4j가 더 풍부한 기능으로 널리 사용되고 있었다. 이후 Apache Commons Logging(JCL)도 등장하면서 자바 진영의 로깅은 다양화되었다.

### 로깅 라이브러리의 다양화와 문제점

| 로깅 구현체 | 출시 연도 | 특징 |
|------------|-----------|-------|
| Log4j 1.x | 1999 | 최초의 널리 사용된 로깅 프레임워크 |
| JUL | 2002 | Java 공식 로깅 API, 하지만 기능이 제한적 |
| Commons Logging | 2002 | Spring Framework의 기본 로깅 시스템 |
| Logback | 2006 | Log4j 제작자가 만든 새로운 구현체 |
| Log4j 2 | 2014 | Log4j 1.x의 완전한 재작성 버전 |

이렇게 다양한 로깅 라이브러리가 등장하면서 새로운 문제가 생겼다. Hibernate 같은 라이브러리가 Log4j에 의존하고, Spring은 Commons Logging을 사용하는 식으로 각자 다른 로깅 라이브러리를 사용하면서 프로젝트에 여러 로깅 프레임워크가 혼재하게 되었다. [^2]

### Facade 패턴을 통한 해결

Facade 패턴은 복잡한 시스템을 간단한 인터페이스로 감싸는 디자인 패턴이다. 마치 건물의 정면(facade)처럼, 내부의 복잡한 구조를 감추고 깔끔한 외관을 제공한다.

![Facade Pattern in SLF4J](https://slf4j.org/images/concrete-bindings.png)
*출처: SLF4J 공식 문서*

SLF4J는 이 패턴을 활용해서:
1. 로깅을 위한 간단한 인터페이스를 제공하고
2. 실제 로깅 작업은 선택된 구현체(Logback, Log4j 등)에 위임한다

이를 통해:
- 라이브러리 제작자는 특정 로깅 구현체에 의존하지 않고 SLF4J 인터페이스만 사용하면 된다
- 라이브러리 사용자는 자신이 선호하는 로깅 구현체를 자유롭게 선택할 수 있다
- 프로젝트의 로깅 구현체를 변경하더라도 코드를 수정할 필요가 없다

실제로 Spring Framework는 5.0 버전부터 내부 로깅 구현을 Commons Logging에서 SLF4J로 변경했다. [^3] 이는 SLF4J가 업계 표준으로 자리잡았음을 보여주는 좋은 예시다.

[^1]: "The Problem With Logging", Martin Fowler's Blog, 2003
[^2]: SLF4J FAQ: https://www.slf4j.org/faq.html#why_not_log4j
[^3]: Spring Framework Documentation: https://docs.spring.io/spring-framework/reference/core/logging.html



## SLF4J 인터페이스 이해하기

### Logger 인터페이스의 핵심 기능
SLF4J의 핵심은 `org.slf4j.Logger` 인터페이스다. 보통 우리가 코드에서 흔히 사용하는 방식은 이렇다:

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Slf4j  // Lombok annotation
public class UserService {
    // @Slf4j가 아래 코드를 자동으로 생성한다
    // private static final Logger log = LoggerFactory.getLogger(UserService.class);

    public void createUser(String username) {
        log.info("Creating user: {}", username);
        if (username == null) {
            log.error("Username cannot be null");
            throw new IllegalArgumentException("Username cannot be null");
        }
    }
}
```

Logger 인터페이스는 다섯 가지 로그 레벨을 제공한다:

- TRACE: 가장 상세한 로깅 레벨
- DEBUG: 개발 단계에서 유용한 디버깅 정보
- INFO: 일반적인 정보성 메시지
- WARN: 잠재적인 문제 상황
- ERROR: 에러 상황

### 로그 메시지 포매팅
SLF4J는 다양한 방식의 메시지 포매팅을 지원한다:
```java
// 1. 단순 문자열
log.info("User login successful");

// 2. 매개변수 치환 - 가장 권장되는 방식
log.info("User {} logged in from IP {}", username, ipAddress);

// 3. 예외 스택트레이스 포함
try {
    // some code
} catch (Exception e) {
    log.error("Failed to process request", e);
}
```

매개변수 치환 방식({})을 사용하는 것이 문자열 연결(+)보다 권장되는 이유는:

실제 로깅이 필요할 때만 문자열이 생성되어 성능상 이점이 있다
코드가 더 읽기 쉽고 유지보수가 용이하다
null 값에 대해 안전하다

### Marker 기능
Marker는 로그 메시지에 메타데이터를 추가하는 방법이다:

```java
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

public class SecurityAuditService {
    private static final Marker SECURITY_MARKER = MarkerFactory.getMarker("SECURITY");

    public void audit(String action) {
        log.info(SECURITY_MARKER, "Security action performed: {}", action);
    }
}
```

이렇게 마커를 사용하면 특정 종류의 로그만 필터링하거나 특별히 처리하는 것이 가능하다.

### MDC (Mapped Diagnostic Context)
MDC는 로그 메시지에 문맥 정보를 추가하는 기능이다:

```java
import org.slf4j.MDC;

public class WebRequestHandler {
    public void handleRequest(String requestId, String userId) {
        MDC.put("requestId", requestId);
        MDC.put("userId", userId);
        try {
            log.info("Processing request");  // 로그에 requestId와 userId가 자동으로 포함됨
            // 비즈니스 로직
        } finally {
            MDC.clear();  // MDC 정보 정리
        }
    }
}
```

이러한 기능들은 실제 구현체(Logback, Log4j2 등)에서 어떻게 구현하느냐에 따라 다양한 방식으로 활용될 수 있다. SLF4J는 이런 기능들의 인터페이스만 정의하고, 실제 구현은 각 로깅 라이브러리에 맡기는 것이다.


## 커스텀 로깅 구현체 만들기

### 왜 커스텀 구현체가 필요한가?
Logback은 훌륭한 구현체지만, 몇 가지 불편한 점이 있다:
- XML 기반의 설정이 복잡하고 가독성이 떨어진다
- Spring Profile별로 설정을 분리할 때 설정이 중복된다
- JSON 포맷으로 로그를 출력하려면 별도의 인코더 설정이 필요하다

이런 문제들을 해결하기 위해 Java 코드로 직접 제어할 수 있는 구현체를 만들어보자.

### TDD로 시작하기
먼저 gradle 설정으로 필요한 의존성을 추가한다:

```gradle
dependencies {
    implementation 'org.slf4j:slf4j-api:2.0.9'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testImplementation 'org.assertj:assertj-core:3.24.2'
}
```

기본적인 로깅 기능에 대한 테스트부터 작성한다:

```java
@Test
@DisplayName("로그 메시지가 지정된 형식으로 출력되어야 한다")
void logFormatTest() {
    // given
    Logger logger = LoggerFactory.getLogger("TestLogger");
    String message = "Test message";

    // when
    logger.info(message);

    // then
    assertThat(outputStream.toString())
        .matches("\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\] \\[INFO\\] \\[TestLogger\\] Test message\n");
}
```

### 커스텀 로거 구현
테스트를 통과시키기 위한 기본 로거를 구현한다:

```java
public class CustomLogger {
    private final String name;
    private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public CustomLogger(String name) {
        this.name = name;
    }

    public void info(String message) {
        String now = LocalDateTime.now().format(formatter);
        System.out.printf("[%s] [INFO] [%s] %s%n", now, name, message);
    }
}
```

### SLF4J 어댑터 구현
이제 SLF4J의 Logger 인터페이스를 구현하는 어댑터를 만든다:

```java
public class CustomLoggerAdapter implements Logger {
    private final CustomLogger logger;
    private final String name;

    public CustomLoggerAdapter(String name) {
        this.name = name;
        this.logger = new CustomLogger(name);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void info(String msg) {
        logger.info(msg);
    }

    // ... 다른 메서드들 구현
}
```

### ServiceProvider 구현
SLF4J가 우리의 구현체를 찾을 수 있도록 ServiceProvider를 구현한다:

```java
public class CustomLoggerServiceProvider implements SLF4JServiceProvider {
    private ILoggerFactory loggerFactory;

    @Override
    public ILoggerFactory getLoggerFactory() {
        return loggerFactory;
    }

    @Override
    public void initialize() {
        loggerFactory = new CustomLoggerFactory();
    }

    @Override
    public String getRequestedApiVersion() {
        return "2.0.0";
    }
}
```

마지막으로 `src/main/resources/META-INF/services/org.slf4j.spi.SLF4JServiceProvider` 파일을 생성하고 우리의 ServiceProvider 클래스를 등록한다:

```
org.example.logging.CustomLoggerServiceProvider
```

이제 기본적인 구현체가 완성되었다. 이를 기반으로 JSON 포맷 출력이나 profile별 설정과 같은 추가 기능을 구현할 수 있다.


## 커스텀 로깅 구현체 활용

### JSON 포맷 로깅 구현
기존 Logback에서는 JSON 포맷 로깅을 위해 logstash-logback-encoder와 같은 추가 라이브러리가 필요했다. 우리의 커스텀 구현체에서는 이를 직접 구현해보자:

```java
public class JsonLogger extends CustomLogger {
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void log(LogLevel level, String message, Object... args) {
        Map<String, Object> logData = new LinkedHashMap<>();
        logData.put("timestamp", LocalDateTime.now().format(formatter));
        logData.put("level", level);
        logData.put("logger", getName());
        logData.put("message", formatMessage(message, args));
        logData.put("thread", Thread.currentThread().getName());

        // MDC 데이터 추가
        Map<String, String> mdcData = MDC.getCopyOfContextMap();
        if (mdcData != null) {
            logData.put("context", mdcData);
        }

        try {
            System.out.println(objectMapper.writeValueAsString(logData));
        } catch (JsonProcessingException e) {
            System.err.println("Failed to serialize log message to JSON");
        }
    }
}
```

이제 로그가 다음과 같은 JSON 형식으로 출력된다:
```json
{
  "timestamp": "2025-01-19 14:30:22",
  "level": "INFO",
  "logger": "com.example.UserService",
  "message": "User john.doe logged in",
  "thread": "http-nio-8080-exec-1",
  "context": {
    "requestId": "abc123",
    "userId": "john.doe"
  }
}
```

### Profile별 설정 분리
Spring의 profile 처럼 환경별로 다른 로깅 설정을 적용할 수 있다:

```java
public class ProfileAwareLoggerFactory implements ILoggerFactory {
    private final Map<String, LoggerConfig> profileConfigs = new HashMap<>();
    private final String activeProfile;

    public ProfileAwareLoggerFactory() {
        this.activeProfile = System.getProperty("logging.profile", "default");

        // 개발 환경 설정
        profileConfigs.put("dev", new LoggerConfig()
            .setLogLevel(LogLevel.DEBUG)
            .setFormat(LogFormat.PLAIN)
            .setOutput(new ConsoleOutput()));

        // 운영 환경 설정
        profileConfigs.put("prod", new LoggerConfig()
            .setLogLevel(LogLevel.INFO)
            .setFormat(LogFormat.JSON)
            .setOutput(new FileOutput("/var/log/application.log")));
    }

    @Override
    public Logger getLogger(String name) {
        LoggerConfig config = profileConfigs.getOrDefault(activeProfile,
            profileConfigs.get("default"));
        return new ConfigurableLogger(name, config);
    }
}
```

### 성능 고려사항
로깅은 애플리케이션의 성능에 큰 영향을 미칠 수 있다. 다음과 같은 최적화를 적용했다:

1. 메시지 포매팅 지연
```java
public void debug(String format, Object... args) {
    if (!isDebugEnabled()) {
        return;  // 조기 반환으로 불필요한 문자열 생성 방지
    }
    String message = formatMessage(format, args);
    log(LogLevel.DEBUG, message);
}
```

2. 비동기 로깅 지원
```java
public class AsyncLogger extends ConfigurableLogger {
    private final ExecutorService executor =
        Executors.newSingleThreadExecutor(new CustomThreadFactory("async-logger"));

    @Override
    protected void log(LogLevel level, String message) {
        executor.submit(() -> super.log(level, message));
    }
}
```

3. 버퍼링과 배치 처리
```java
public class BufferedLogger extends ConfigurableLogger {
    private final Queue<LogEntry> buffer = new ArrayBlockingQueue<>(1000);

    @Scheduled(fixedRate = 1000)  // 1초마다 버퍼 플러시
    public void flushBuffer() {
        List<LogEntry> entries = new ArrayList<>();
        buffer.drainTo(entries);
        if (!entries.isEmpty()) {
            writeEntries(entries);
        }
    }
}
```

이러한 최적화를 통해 로깅이 애플리케이션의 주요 로직에 미치는 영향을 최소화할 수 있다.

## 배운 점과 앞으로의 과제

### 배운 점
처음에는 단순히 '@Slf4j' 애노테이션만 사용하던 내가 이번 학습을 통해 얻은 것들:

1. **인터페이스의 가치**
SLF4J가 단순한 로깅 라이브러리가 아닌, 잘 설계된 인터페이스라는 것을 알게 되었다. 이를 통해 왜 많은 자바 오픈소스들이 SLF4J를 선택했는지 이해할 수 있었다.

2. **디자인 패턴의 실제 사례**
Facade 패턴이 실제로 어떻게 사용되는지, 그리고 그것이 어떤 문제를 해결하는지 직접 경험했다. 특히 로깅이라는 구체적인 문제 영역에서 이 패턴이 주는 이점을 확실히 이해할 수 있었다.

3. **Java SPI의 발견**
처음 알게 된 Java SPI(Service Provider Interface) 메커니즘은 매우 흥미로웠다. 플러그인 방식으로 구현체를 바꿀 수 있다는 점이 인상적이었다.

### 아쉬운 점과 개선할 부분

1. **성능 테스트 부족**
실제 운영 환경에서 얼마나 성능이 나올지 테스트하지 못했다. 특히 비동기 처리나 버퍼링을 적용했을 때의 실제 성능 개선 정도를 측정해보지 못한 것이 아쉽다.

2. **기능의 한계**
Logback이 제공하는 많은 기능들 중 일부만 구현했다. 특히:
- 로그 파일 롤링
- 로그 레벨의 동적 변경
- 조건부 로깅
등의 기능은 아직 구현하지 못했다.

### 앞으로의 과제

1. **Kotlin 지원**
현재는 Java만 고려했지만, Kotlin의 코루틴과 같은 비동기 프로그래밍 모델에서도 잘 동작하도록 개선이 필요하다.

2. **Spring Boot Auto Configuration**
Spring Boot에서 자동으로 설정될 수 있도록 auto-configuration을 제공하면 좋을 것 같다.

3. **모니터링 도구 연동**
ELK 스택이나 Datadog 같은 모니터링 도구와의 연동을 기본적으로 지원하면 좋을 것 같다.

### 마치며
이번 경험을 통해 단순히 라이브러리를 사용하는 것을 넘어서서, 왜 이렇게 설계되었는지 이해할 수 있었다. 특히 인터페이스 설계의 중요성과 그것이 주는 유연성을 직접 체감할 수 있었다. 앞으로도 자주 사용하는 라이브러리들의 내부를 이해하려 노력해야겠다는 생각이 든다.
